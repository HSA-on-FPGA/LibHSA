// Copyright (C) 2017 Philipp Holzinger
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <iostream>
#include <cstdint>
#include <string>
#include <fstream>
#include <vector>

void tokenize(std::string line, std::vector<std::string> &vec, char separator){
	unsigned int last = 0;
	unsigned int length = 0;
	for(unsigned int i=0; i<line.length(); ++i){
		if(line[i]==separator){
			std::string item = line.substr(last,length);
			vec.push_back(item);
			last = i+1;
			length = 0;
		}else{
			++length;
		}
	}
	if(line.length() >= 1){
		if(line[line.length()-1]!=separator){
			std::string item = line.substr(last,length);
			vec.push_back(item);
		}
	}
}

int main(int argc, char *argv[]){
	
	if(argc != 2){
		std::cout << "wrong usage: argument must be file with configuration" << std::endl;
		return EXIT_FAILURE;
	}
	
	std::ifstream config_file(argv[1]);
	if(!config_file.is_open()){
		std::cerr << "ERROR: could not open file " << argv[1] << std::endl;
		return EXIT_FAILURE;
	}
	std::ofstream outfile("code_segments.h");

	// read header
	std::string config_line = "";
	std::getline(config_file,config_line);
	if(config_file.eof()){
		std::cerr << "ERROR: wrong file format - empty input file!!" << std::endl;
		return EXIT_FAILURE;
	}
	std::vector<std::string> header_strings;
	tokenize(config_line, header_strings,' ');
	
	// read code paths and data sizes	
	std::vector<std::vector<std::string>> system_strings;
	std::getline(config_file,config_line);
	while(!config_file.eof()){
		std::vector<std::string> processor_strings;
		tokenize(config_line, processor_strings,' ');
		system_strings.push_back(processor_strings);
		if(processor_strings.size() != 3){
			std::cerr << "ERROR: wrong line format: " << config_line << std::endl;
			return EXIT_FAILURE;
		}
		std::getline(config_file,config_line);
	}

	// write output file header
	outfile << "// this file is machine generated by vsim2cmd, do not edit below!!!" << std::endl;
	outfile << "#ifndef CODE_SEGMENTS_H_" << std::endl;
	outfile << "#define CODE_SEGMENTS_H_" << std::endl << std::endl;
	
	outfile << "#include <stdint.h>"      << std::endl << std::endl;

	// write segment struct definition
	outfile << "typedef struct code_segment_s{" << std::endl;
	outfile << "    uint64_t *instructions;"    << std::endl;
	outfile << "    uint64_t *data;"            << std::endl;
	outfile << "    uint64_t imem_length;"      << std::endl;
	outfile << "    uint64_t dmem_length;"      << std::endl;
	outfile << "} code_segment_t;"              << std::endl << std::endl;

	// generate code dump as C arrays
	std::vector<std::string> generated_variables;
	std::vector<int> imem_sizes;
	std::vector<int> dmem_sizes;
	for(unsigned int i=0; i<system_strings.size(); ++i){
		std::string instr_path(system_strings[i][0]);
		std::string data_path(system_strings[i][0]);
		std::string cpu_code[2] = {instr_path.append("instr.mem"),data_path.append("data.mem")};
		for(unsigned int j=0; j<2; ++j){
			std::ifstream mti_file(cpu_code[j]);
			if(!mti_file.is_open()){
				std::cerr << "ERROR: could not open file " << cpu_code[j] << std::endl;
				return EXIT_FAILURE;
			}
			std::string mti_line = "";
			// read mti file header
			std::getline(mti_file,mti_line);
			std::getline(mti_file,mti_line);
			std::vector<std::string> mti_header;
			tokenize(mti_line,mti_header,' ');
			
			unsigned int words_per_line = 0;
			for(unsigned int entry=0; entry<mti_header.size(); ++entry){
				std::vector<std::string> kv;
				tokenize(mti_header[entry],kv,'=');
				if(kv[0].compare("wordsperline")==0){
					words_per_line = std::stoi(kv[1]);
					if(words_per_line != 2 && words_per_line !=4){
						std::cerr << "ERROR: " << words_per_line << " not supported!" << std::endl;
						return EXIT_FAILURE;
					}
				}
			}

			// declare variable name
			std::string var_name = "text_segment";
			if(j==1){
				var_name = "data_segment";
			}
			var_name.append(std::to_string((long long unsigned int)i));
			generated_variables.push_back(var_name);

			int blocksize = std::stoi(system_strings[i][j+1]) * 4096 / 8;
			outfile << "uint64_t " << var_name << "[" << blocksize << "] = {" << std::endl << "    ";
			
			if(j==0){
				imem_sizes.push_back(blocksize);
			}else{
				dmem_sizes.push_back(blocksize);
			}
			
			// read data and dump it in new format
			unsigned int max_index = (unsigned int)blocksize;
			if(words_per_line == 2){
				unsigned int index = 0;
				while(index<max_index){
					std::vector<std::string> mti_strings;
					int mti_index = blocksize;
					std::getline(mti_file,mti_line);
					if(!mti_file.eof()){
						tokenize(mti_line,mti_strings,' ');
						mti_index = std::stoi(mti_strings[0].substr(0,mti_strings[0].length()-1));
					}

					// fill with zeros if some values are not in the file
					while(index < mti_index){
						outfile << "0x0000000000000000";
						if(index != max_index-1){
							outfile << ", ";
						}
						if((index&1) == 1){
							outfile << std::endl << "    ";
						}
						++index;
					}

					// write data if present
					for(unsigned int entry=1; entry<mti_strings.size() && index<max_index; ++entry){
						outfile << "0x" << mti_strings[entry];
						if(index != max_index-1){
							outfile << ", ";
						}
						if((index&1) == 1){
							outfile << std::endl << "    ";
						}
						++index;
					}
				}
			}else if(words_per_line == 4){
				max_index *= 2;
				unsigned int index = 0;
				std::string last_value = "";
				while(index<max_index){
					std::vector<std::string> mti_strings;
					int mti_index = blocksize;
					std::getline(mti_file,mti_line);
					if(!mti_file.eof()){
						tokenize(mti_line,mti_strings,' ');
						mti_index = std::stoi(mti_strings[0].substr(0,mti_strings[0].length()-1));
					}

					// fill with zeros if some values are not in the file
					while(index < mti_index){
						std::string current_value = "";
						current_value = "00000000";
						if((index&1) == 1){
							outfile << "0x" << current_value << last_value;
							if(index != max_index-1){
								outfile << ", ";
							}
						}
						if((index&3) == 3){
							outfile << std::endl << "    ";
						}
						++index;
						last_value = current_value;
					}

					// write data if present
					for(unsigned int entry=1; entry<mti_strings.size() && index<max_index; ++entry){
						std::string current_value = "";
						current_value = mti_strings[entry];
						if((index&1) == 1){
							outfile << "0x" << current_value << last_value;
							if(index != max_index-1){
								outfile << ", ";
							}
						}
						if((index&3) == 3){
							outfile << std::endl << "    ";
						}
						++index;
						last_value = current_value;
					}
				}
			}else{
				std::cerr << "ERROR: unsupported number of words per line. Only standard MIPS mti files supported. This means 2 64 bit or 4 32 bit words per line!!" << std::endl;
				return EXIT_FAILURE;
			}
			outfile << "};" << std::endl << std::endl;
		}
	}

	// generate segment struct array
	outfile << "code_segment_t code_vector[" << header_strings.size() << "] = {" << std::endl;
	
	for(unsigned int i=0; i<header_strings.size(); ++i){
		if(header_strings[i].compare("-")==0){
			outfile << "    {NULL,NULL,0,0}";
		}else{
			int program_index = std::stoi(header_strings[i]);
			outfile << "    {" << generated_variables[program_index*2] << ","<< generated_variables[program_index*2 + 1] << "," << imem_sizes[program_index] << "," << dmem_sizes[program_index] << "}";
		}
		if(i != header_strings.size()-1){
			outfile << ",";
		}
		outfile << std::endl;
	}

	outfile << "};" << std::endl << std::endl;
	
	outfile << "#endif" << std::endl;
}
